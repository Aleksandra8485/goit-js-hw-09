{"mappings":"oeACAA,EAAA,SAGE,MAAIC,EAAUC,SAASC,cAAc,qBACjCC,EAASF,SAASC,cAAc,oBAChCE,EAAWH,SAASC,cAAc,sBACtBD,SAASC,cAAc,uBA8C/BG,iBAAiB,SAAS,SAAUC,GAC5CA,EAAMC,iBACN,MAAQC,MAAOC,GAAWL,GAClBI,MAAOE,GAASP,GAChBK,MAAOG,GAAUX,C","sources":["src/js/03-promises.js"],"sourcesContent":["// importowanie biblioteki\nimport Notiflix from 'notiflix';\n\n// pobieram dostęp do inputów i buttona\nconst delayEl = document.querySelector('input[name=delay]');\nconst stepEl = document.querySelector('input[name=step]');\nconst amountEl = document.querySelector('input[name=amount]');\nconst submitBtn = document.querySelector('button[type=submit]');\n\n// funkcja createPromise zwraca nową obietnicę\nfunction createPromise(position, delay) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const shouldResolve = Math.random() > 0.3;\n      if (shouldResolve) {\n        resolve(`✅ Fulfilled promise ${position} in ${delay}ms`);\n      } else {\n        reject(`❌ Rejected promise ${position} in ${delay}ms`);\n      }\n    }, delay);\n  });\n}\n\n// funkcja asynchroniczna myPromise- tworząca wiele obietnic dzięki createPromise\n// wykonana tyle razy ile podane w amount\n// step i time-określają różnicę czasową między kolejnymi obietnicami i czas, w którym zostanie utworzona pierwsza obietnica\n// domyślnie/current ustawione są na 1.\nasync function myPromise(amount, step, time, current = 1) {\n  if (current > amount) return;\n\n  // try...catch\n  // Najpierw wykonywany jest kod wewnątrz bloku try.\n  // Jeśli nie ma błędów, blok catch jest ignorowany, a interpreter idzie dalej.\n  // Jeśli w bloku try wystąpi błąd, jego wykonanie zostaje zatrzymane, a interpreter przejdzie do bloku catch.\n  // try-catch, obsługuje wynik każdej obietnicy\n  // wyświetla powiadomienia Notiflix w zależności od wyniku\n  try {\n    const success = await createPromise(current, time);\n    Notiflix.Notify.success(success);\n  } catch (error) {\n    Notiflix.Notify.failure(error);\n  }\n  // po każdej wykonanej obietnicy time zwiększa się o step\n  // funcja myPromise wywoływana jest rekurencyjnie/przez samą siebie\n  // ze zwiększoną wartością current, aż current przekroczy ammount\n  time += step;\n  setTimeout(() => myPromise(amount, step, time, current + 1), time);\n}\n\n// wywołanie funkcji myPromise po kliknięciu submitBtn\n// funkcja myPromise wywoława z wartościami amount, step i delay jako parametrami\n// amount, step i delay-pobrane z formularza (zmienne na górze)\n// delay- opóźnienie czasowe przed rozpoczęciem wykonywanie myPromise\nsubmitBtn.addEventListener('click', function (event) {\n  event.preventDefault();\n  const { value: amount } = amountEl;\n  const { value: step } = stepEl;\n  const { value: delay } = delayEl;\n  // setTimeout(() => myPromise(+amount, +step, +delay), +delay);\n  let time = +delay;\n});\n"],"names":["parcelRequire","$47d4ff9957288465$var$delayEl","document","querySelector","$47d4ff9957288465$var$stepEl","$47d4ff9957288465$var$amountEl","addEventListener","event","preventDefault","value","amount","step","delay"],"version":3,"file":"03-promises.055aa1b7.js.map"}