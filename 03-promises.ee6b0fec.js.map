{"mappings":"qhBACA,IAAAA,EAAAC,EAAA,SAGE,MAAIC,EAAUC,SAASC,cAAc,qBACjCC,EAASF,SAASC,cAAc,oBAChCE,EAAWH,SAASC,cAAc,sBAqBtCG,eAAaC,EAAUC,EAAQC,EAAMC,EAAMC,EAAU,GACrD,KAAIA,EAAUH,GAAd,CAQG,IACD,MAAMI,QA3BaC,EA2BiBF,EA3BPG,EA2BgBJ,EA1BxC,IAAIK,SAAQ,CAACC,EAASC,KAC3BC,YAAW,KACaC,KAAKC,SAAW,GAEpCJ,EAAQ,uBAAqBH,QAAiBC,OAE5CG,EAAK,sBAAoBJ,QAAiBC,MAAU,GAEvDA,EAAM,KAmBTO,EAAAtB,GAASuB,OAAOV,QAAQA,E,CACxB,MAAOW,GACPF,EAAAtB,GAASuB,OAAOE,QAAQD,E,CA9B1B,IAAqBV,EAAUC,EAmC1BJ,GAAGD,EACRS,YAAW,IAAMX,EAAUC,EAAQC,EAAMC,EAAMC,EAAU,IAAID,EAlBvC,C,CArBNR,SAASC,cAAc,uBA8C/BsB,iBAAiB,SAAS,SAAUC,GAC5CA,EAAMC,iBACN,MAAQC,MAAOpB,GAAWH,GAClBuB,MAAOnB,GAASL,GAChBwB,MAAOd,GAAUb,EACzBiB,YAAW,IAAMX,GAAWC,GAASC,GAAOK,KAASA,E","sources":["src/js/03-promises.js"],"sourcesContent":["// importowanie biblioteki\nimport Notiflix from 'notiflix';\n\n// pobieram dostęp do inputów i buttona\nconst delayEl = document.querySelector('input[name=delay]');\nconst stepEl = document.querySelector('input[name=step]');\nconst amountEl = document.querySelector('input[name=amount]');\nconst submitBtn = document.querySelector('button[type=submit]');\n\n// funkcja createPromise zwraca nową obietnicę\nfunction createPromise(position, delay) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const shouldResolve = Math.random() > 0.3;\n      if (shouldResolve) {\n        resolve(`✅ Fulfilled promise ${position} in ${delay}ms`);\n      } else {\n        reject(`❌ Rejected promise ${position} in ${delay}ms`);\n      }\n    }, delay);\n  });\n}\n\n// funkcja asynchroniczna myPromise- tworząca wiele obietnic dzięki createPromise\n// wykonana tyle razy ile podane w amount\n// step i time-określają różnicę czasową między kolejnymi obietnicami i czas, w którym zostanie utworzona pierwsza obietnica\n// domyślnie/current ustawione są na 1.\nasync function myPromise(amount, step, time, current = 1) {\n  if (current > amount) return;\n\n  // try...catch\n  // Najpierw wykonywany jest kod wewnątrz bloku try.\n  // Jeśli nie ma błędów, blok catch jest ignorowany, a interpreter idzie dalej.\n  // Jeśli w bloku try wystąpi błąd, jego wykonanie zostaje zatrzymane, a interpreter przejdzie do bloku catch.\n  // try-catch, obsługuje wynik każdej obietnicy\n  // wyświetla powiadomienia Notiflix w zależności od wyniku\n  try {\n    const success = await createPromise(current, time);\n    Notiflix.Notify.success(success);\n  } catch (error) {\n    Notiflix.Notify.failure(error);\n  }\n  // po każdej wykonanej obietnicy time zwiększa się o step\n  // funcja myPromise wywoływana jest rekurencyjnie/przez samą siebie\n  // ze zwiększoną wartością current, aż current przekroczy ammount\n  time += step;\n  setTimeout(() => myPromise(amount, step, time, current + 1), time);\n}\n\n// wywołanie funkcji myPromise po kliknięciu submitBtn\n// funkcja myPromise wywoława z wartościami amount, step i delay jako parametrami\n// amount, step i delay-pobrane z formularza (zmienne na górze)\n// delay- opóźnienie czasowe przed rozpoczęciem wykonywanie myPromise\nsubmitBtn.addEventListener('click', function (event) {\n  event.preventDefault();\n  const { value: amount } = amountEl;\n  const { value: step } = stepEl;\n  const { value: delay } = delayEl;\n  setTimeout(() => myPromise(+amount, +step, +delay), +delay);\n  let time = +delay;\n});\n"],"names":["$7Y9D8","parcelRequire","$47d4ff9957288465$var$delayEl","document","querySelector","$47d4ff9957288465$var$stepEl","$47d4ff9957288465$var$amountEl","async","$47d4ff9957288465$var$myPromise","amount","step","time","current","success","position","delay","Promise","resolve","reject","setTimeout","Math","random","$parcel$interopDefault","Notify","error","failure","addEventListener","event","preventDefault","value"],"version":3,"file":"03-promises.ee6b0fec.js.map"}